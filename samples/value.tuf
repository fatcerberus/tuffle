/**
 *  The simplest data type is a 'value'.  Value types consist of one or more identifiers, called
 *  tags, followed by zero or more type expressions specifying the kind of data a value with that
 *  tag carries.  The overall type can be defined recursively (i.e. in terms of itself).  Droste types
 *  are allowed but can only safely be constructed by a lazy function!
 *
 *  Unions have pass-by-value semantics: assignment makes a copy of the data.  Note that
 *  the individual tags of a union are not types themselves; they are more like operators
 *  that provide a way to construct literal values for the type.
**/

value Tree[+T] = leaf | node T, Tree[T], Tree[T]

/**
 *  If a type parameter isn't directly used in a tag, the resulting value will be polymorphic
 *  (i.e. it will work as a value for any instantiation of the type).  If that's not desired,
 *  the type parameter can be forced to a specific type.
 */

value Expr[+T] =
	| litInt int => T = int
	| litBool bool => T = bool
	| eqExpr Expr<U>, Expr<U> => T = bool
	| mulExpr Expr<int>, Expr<int> => T = int
	| addExpr Expr<int>, Expr<int> => T = int
